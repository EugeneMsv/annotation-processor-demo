package com.github.eugenemsv.poet.processor;

import com.google.auto.service.AutoService;
import com.squareup.javapoet.*;

import javax.annotation.processing.*;
import javax.lang.model.SourceVersion;
import javax.lang.model.element.Element;
import javax.lang.model.element.ElementKind;
import javax.lang.model.element.Modifier;
import javax.lang.model.element.TypeElement;
import javax.lang.model.type.ExecutableType;
import javax.lang.model.type.TypeMirror;
import java.io.IOException;
import java.util.LinkedList;
import java.util.List;
import java.util.Set;

@SupportedAnnotationTypes("com.github.eugenemsv.poet.annotation.Query")
@SupportedSourceVersion(SourceVersion.RELEASE_11)
@AutoService(Processor.class)
public class QueryProcessor extends AbstractProcessor {


    @Override
    public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {
        for (TypeElement annotation : annotations) {
            Set<? extends Element> elements = roundEnv.getElementsAnnotatedWith(annotation);
            for (Element element : elements) {
                handleSingleElement(element);
            }

        }

        return true;
    }

    private void handleSingleElement(Element element) {
        List<? extends Element> methodCandidates = element.getEnclosedElements();

        List<MethodSpec> methodSpecs = new LinkedList<>();
        List<FieldSpec> fieldSpecs = new LinkedList<>();
        List<ParameterSpec> parameterSpec = new LinkedList<>();
        for (Element methodCandidate : methodCandidates) {
            if (methodCandidate.getKind() != ElementKind.METHOD) {
                continue;
            }

            ExecutableType executableType = (ExecutableType) methodCandidate.asType();
            TypeName typeName = extractTypeName(executableType.getReturnType());
            String name = methodCandidate.getSimpleName().toString();
            FieldSpec fieldSpec = FieldSpec.builder(typeName, name, Modifier.PRIVATE).build();
            fieldSpecs.add(fieldSpec);
            methodSpecs.add(
                    MethodSpec.methodBuilder(name)
                            .addModifiers(Modifier.PUBLIC)
                            .returns(typeName)
                            .addStatement("return this." + fieldSpec.name)
                            .build());
            parameterSpec.add(ParameterSpec.builder(typeName, name).build());
        }

        TypeSpec typeSpec = TypeSpec.classBuilder(extractSimpleClassName((TypeElement) element) + "Impl")
                .addModifiers(Modifier.PUBLIC)
                .addSuperinterface(element.asType())
                .addFields(fieldSpecs)
                .addMethod(buildAllArgsConstructor(parameterSpec))
                .addMethods(methodSpecs)
                .build();

        JavaFile javaFile = JavaFile.builder(extractPackage(element), typeSpec)
                .addFileComment("Autogenerated class")
                .build();

        writeFile(javaFile);

    }

    private void writeFile(JavaFile javaFile) {
        try {
            javaFile.writeTo(processingEnv.getFiler());
        } catch (IOException e) {
            throw new RuntimeException("Failed to autogenerate file", e);
        }
    }

    private MethodSpec buildAllArgsConstructor(List<ParameterSpec> parameterSpec) {
        MethodSpec.Builder constructorBuilder = MethodSpec.constructorBuilder()
                .addModifiers(Modifier.PUBLIC)
                .addParameters(parameterSpec);
        for (ParameterSpec constructorParameter : parameterSpec) {
            constructorBuilder.addStatement("this.$N = $N", constructorParameter.name, constructorParameter.name);
        }
        MethodSpec constructor = constructorBuilder
                .build();
        return constructor;
    }

    private TypeName extractTypeName(TypeMirror typeMirror) {
        return TypeName.get(typeMirror);
    }

    private String extractPackage(Element element) {
        return processingEnv.getElementUtils().getPackageOf(element).getQualifiedName().toString();
    }

    private String extractSimpleClassName(TypeElement element) {
        String className = element.getQualifiedName().toString();
        int lastDot = className.lastIndexOf('.');
        return className.substring(lastDot + 1);
    }
}
